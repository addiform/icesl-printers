-- RepRapFirmware Configurable Printer Profile (Addiform_RRF) for IceSL
-- created on 2020-APR-20 by Nathan Buxton for Addiform (https://addiform.com)

-- Version 1.0

-- printer.lua
-- Last modified:
-- File created. 2020-APR-20 NaB

--     This file is not intended to be modified by the user, unless to implement new features, fix
--     bugs, or modify behaviour. Refer to features.lua for user-configurable printer parameters.


-- Variable initializations:
previous_path_was = "nothing"
current_layer_zheight = 0
previous_layer_zheight = 0
current_layer_thickness = 0
previous_layer_thickness = 0
previous_x = 0
previous_y = 0
previous_z = 0
filament_to_extrude_this_move = 0
move_volume = 0
move_length = 0
previous_move_calculated_extrusion_width = 0
current_move_calculated_extrusion_width = 0
current_feedrate = 0
previous_feedrate = 0
current_extruder = -1
previous_extruder = -1
selecting_tools_at_start = false
current_fan_speed = -1
previous_fan_speed = -1
already_extruded = {}

for i = 0, max_number_extruders - 1 do
    already_extruded[i] = 0
end


-- Error checks:
-- Absolute Extrusion not yet implemented:
if not relative_extrusion then print("\nWarning: Absolute extrusion is not yet implemented in this profile.\nNo extrusion values will be produced.\nVolumetric Extrusion requires Relative Extrusion to be enabled.") end

-- CraftWare Path Labeling and S3D Output Emulation conflict:
if s3d_debug and craftware_debug then print("\nWarning: Both CraftWare Path Labeling and S3D Output Emulation are enabled.\nS3D path labels will not be produced.") end

-- Firmware Retraction requires a non-zero retract/prime distance set in the GUI in order to produce retraction commands:
if type(filament_priming_mm) ~= "table" then filament_priming_mm = {} for i = 0, max_number_extruders - 1 do filament_priming_mm[i] = 0 end end -- This is to allow Firmware Retraction check below during IceSL first boot up.
if firmware_retraction and math.max(unpack(filament_priming_mm)) == 0 then print ("\nWarning: The use of Firmware Retraction requires a non-zero retract value.\nRetraction commands may not be produced.") end

-- 'Automatically spiralize' is untested with this profile. Enable with caution. Read the information at: https://groups.google.com/d/msg/icesl/SyA1akzbGjY/QtBB2kFfDwAJ
if auto_spiralize then print("\nWarning: 'Automatically spiralize' has not been tested extensively with this profile.") end


-- Additional helper functions:
function round(number,decimals)
    local power = 10^decimals
    return math.floor(number * power + 0.5) / power
end


-- IceSL printer functions:
function header()
    -- Function Diagnostic output:
    if move_debug then
        comment("header()")
    end

    if s3d_debug then
        comment("G-Code generated by " .. slicer_name .. " Version " .. slicer_version)
        comment(os.date("%b %d, %Y at %I:%M:%S %p"):gsub(" 0"," "))
        comment("Settings Summary")
        comment("  applyToModels," .. filename)
        comment("  profileName," .. printer_name)
        comment("  layerHeight," .. round(z_layer_height_mm,2))
        if use_different_thickness_first_layer then comment("  firstLayerHeightPercentage," .. round((z_layer_height_first_layer_mm / z_layer_height_mm) * 100,0)) else comment("  firstLayerHeightPercentage,100") end
    end
end

function footer()
    -- Function Diagnostic output:
    if function_debug then
        comment("footer()")
    end

    -- GCode output:
    if s3d_debug then
        local filament_total_mm = 0

        for i = 0, number_of_extruders - 1 do
            filament_total_mm = filament_total_mm + filament_tot_length_mm[extruders[i]]
        end

        comment("Build Summary")
        comment("  Build time: " .. math.floor(time_sec / 3600) .. " hours " .. round((time_sec % 3600) / 60,0) .. " minutes")
        comment("  Filament length: " .. round(filament_total_mm, 1) .. " mm (" .. round(filament_total_mm / 1000,2) .. " m)")
        comment("  Plastic volume: " .. round(math.pi * (filament_diameter_mm[extruders[0]] / 2)^2 * filament_total_mm,2) .. " mm^3 (" .. round((math.pi * (filament_diameter_mm[extruders[0]] / 2)^2 * filament_total_mm) / 1000,2) .. " cc)")
        comment("  Plastic weight: " .. round(material_density_g_per_cc * (math.pi * (filament_diameter_mm[extruders[0]] / 2)^2 * filament_total_mm) / 1000,2) .. " g (" .. round(0.00220462 * (material_density_g_per_cc * (math.pi * (filament_diameter_mm[extruders[0]] / 2)^2 * filament_total_mm) / 1000),2) .. " lb)")
        comment("  Material cost: " .. round(material_cost_per_kg * ((material_density_g_per_cc * (math.pi * (filament_diameter_mm[extruders[0]] / 2)^2 * filament_total_mm) / 1000) / 1000),2))
    end
end

function comment(text)
    -- GCode output:
    output("; " .. text:gsub("\n","\n; "))
end

function layer_start(zheight)
    -- Function Diagnostic output:
    if function_debug then
        comment("layer_start(" .. zheight .. ")")
    end

    -- Start GCode first-layer insertion:
    if layer_id == 0 then
        if insert_startpre_gcode then
            local startpre_string = file("startpre.g")
            startpre_string = startpre_string:gsub("\r","")
            startpre_string = startpre_string:gsub("<retract_speed>",round(priming_mm_per_sec[current_extruder]*60,0))
            startpre_string = startpre_string:gsub("<retract_length>",ff(filament_priming_mm[current_extruder]))
            startpre_string = startpre_string:gsub("<extruder_swap_retract_length>",ff(extruder_swap_retract_length_mm))
            startpre_string = startpre_string:gsub("<extruder_swap_retract_speed>",round(extruder_swap_retract_speed_mm_per_sec*60,0))
            startpre_string = startpre_string:gsub("<z_lift>",f(z_lift_mm))
            startpre_string = startpre_string:gsub("<extruder_swap_z_lift>",f(extruder_swap_zlift_mm))
            startpre_string = startpre_string:gsub("<current_layer_zheight>",f(current_layer_zheight))
            startpre_string = startpre_string:gsub("<current_extruder>",current_extruder)
            startpre_string = startpre_string:gsub("<z_movement_speed>",round(z_movement_speed_mm_per_sec*60,0))
            startpre_string = startpre_string:gsub("<e_movement_speed>",round(e_movement_speed_mm_per_sec*60,0))
            startpre_string = startpre_string:gsub("<travel_speed>",round(travel_speed_mm_per_sec*60,0))
            startpre_string = startpre_string:gsub("<print_x_min>",f(min_corner_x))
            startpre_string = startpre_string:gsub("<print_x_max>",f(min_corner_x + extent_x))
            startpre_string = startpre_string:gsub("<print_y_min>",f(min_corner_y))
            startpre_string = startpre_string:gsub("<print_y_max>",f(min_corner_y + extent_y))
            startpre_string = startpre_string:gsub("<print_z_max>",f(extent_z))
            startpre_string = startpre_string:gsub("<fan_percent>",round(current_fan_speed/100,2))

            output(startpre_string)
        end

        output("G21 ; units are mm")
        output("G90 ; absolute coordinates")

        if relative_extrusion then
            output ("M83 ; relative extrusion")
        --else
        --    output ("M82 ; absolute extrusion")
        end

        if volumetric_extrusion and relative_extrusion then
            local d_string = "D" .. f(filament_diameter_mm[0])

            if number_of_extruders > 1 then
                local max_extruder_index = math.max(unpack(extruders))

                for i = 1, max_extruder_index do
                    d_string = d_string .. ":" .. f(filament_diameter_mm[i])
                end
            end

            output("M200 " .. d_string .. " ; volumetric extrusion")
        end

        if firmware_retraction then
            if rrf_3 then
                local z_string = ""
                
                if z_lift_on_retract and enable_z_lift then
                    z_string = " Z" .. f(z_lift_mm)
                end

                for i = 0, number_of_extruders - 1 do
                    output("M207 P" .. extruders[i] .. " S" .. f(filament_priming_mm[extruders[i]]) .. " F" .. round(priming_mm_per_sec[extruders[i]] * 60,0) .. z_string .. " ; firmware retraction")
                end
            elseif z_lift_on_retract and enable_z_lift then
                output("M207 S" .. f(filament_priming_mm[extruders[0]]) .. " F" .. round(priming_mm_per_sec[extruders[0]] * 60,0) .. " Z" .. f(z_lift_mm) .. " ; firmware retraction")
            else
                output("M207 S" .. f(filament_priming_mm[extruders[0]]) .. " F" .. round(priming_mm_per_sec[extruders[0]] * 60,0) .. " ; firmware retraction")
            end
        end

        if insert_start_temp then
            if enable_active_temperature_control then
                for i = 0, number_of_extruders -1 do
                    output("G10 P" .. extruders[i] .. " S" .. round(_G["extruder_temp_degree_c_" .. i],1) .. " R" .. round(_G["idle_extruder_temp_degree_c_" .. i],1))
                end
            else
                for i = 0, number_of_extruders -1 do
                    output("G10 P" .. extruders[i] .. " S" .. round(_G["extruder_temp_degree_c_" .. i],1) .. " R" .. round(default_standby_temp,1))
                end
            end

            if bed_temp_degree_c ~= 0 then
                output("M140 S" .. round(bed_temp_degree_c,1))
            end

            if wait_start_temp then
                output("M116")
            end
        end

        if insert_start_gcode then
            local start_string = file("start.g")
            start_string = start_string:gsub("\r","")
            start_string = start_string:gsub("<retract_speed>",round(priming_mm_per_sec[current_extruder]*60,0))
            start_string = start_string:gsub("<retract_length>",ff(filament_priming_mm[current_extruder]))
            start_string = start_string:gsub("<extruder_swap_retract_length>",ff(extruder_swap_retract_length_mm))
            start_string = start_string:gsub("<extruder_swap_retract_speed>",round(extruder_swap_retract_speed_mm_per_sec*60,0))
            start_string = start_string:gsub("<z_lift>",f(z_lift_mm))
            start_string = start_string:gsub("<extruder_swap_z_lift>",f(extruder_swap_zlift_mm))
            start_string = start_string:gsub("<current_layer_zheight>",f(current_layer_zheight))
            start_string = start_string:gsub("<current_extruder>",current_extruder)
            start_string = start_string:gsub("<z_movement_speed>",round(z_movement_speed_mm_per_sec*60,0))
            start_string = start_string:gsub("<e_movement_speed>",round(e_movement_speed_mm_per_sec*60,0))
            start_string = start_string:gsub("<travel_speed>",round(travel_speed_mm_per_sec*60,0))
            start_string = start_string:gsub("<print_x_min>",f(min_corner_x))
            start_string = start_string:gsub("<print_x_max>",f(min_corner_x + extent_x))
            start_string = start_string:gsub("<print_y_min>",f(min_corner_y))
            start_string = start_string:gsub("<print_y_max>",f(min_corner_y + extent_y))
            start_string = start_string:gsub("<print_z_max>",f(extent_z))
            start_string = start_string:gsub("<fan_percent>",round(current_fan_speed/100,2))

            output(start_string)
        end
    end

    -- Function pre-calculations:
    previous_layer_zheight = current_layer_zheight
    current_layer_zheight = zheight
    previous_layer_thickness = current_layer_thickness
    current_layer_thickness = current_layer_zheight - previous_layer_zheight

    -- Layer labeling:
    if s3d_debug then
        comment("layer " .. layer_id + 1 .. ", Z = " .. f(zheight))
    else
        comment("<layer " .. layer_id .. ">")
    end

    -- S3D Output Emulation for toolpath visualization:
    if s3d_debug then
        if f(current_layer_thickness) ~= f(previous_layer_thickness) then
            comment("tool H" .. f(current_layer_thickness) .. " W" .. f(_G["nozzle_diameter_mm_" .. current_extruder]))
        end
    end

    -- Movement Diagnostic output:
    if move_debug then
        if fff(current_layer_thickness) ~= fff(previous_layer_thickness) then
            comment("LH: " .. fff(previous_layer_thickness) .. " -> " .. fff(current_layer_thickness))
        end
    end

    -- GCode output:
    if current_feedrate ~= z_movement_speed_mm_per_sec * 60 then
        set_feedrate(z_movement_speed_mm_per_sec * 60)
        output("G1 Z" .. f(zheight) .. " F" .. round(current_feedrate,0))
    else
        output("G1 Z" .. f(zheight))
    end

    -- Function post-calculations:
    previous_z = zheight
end

function layer_stop()
    -- Function Diagnostic output:
    if function_debug then
        comment("layer_stop()")
    end

    -- GCode output:
    if layer_id == number_of_layers -1 then
        if s3d_debug then
            comment("layer end")
        end

        if insert_end_gcode then
            local end_string = file("end.g")
            end_string = end_string:gsub("\r","")
            end_string = end_string:gsub("<retract_speed>",round(priming_mm_per_sec[current_extruder]*60,0))
            end_string = end_string:gsub("<retract_length>",ff(filament_priming_mm[current_extruder]))
            end_string = end_string:gsub("<extruder_swap_retract_length>",ff(extruder_swap_retract_length_mm))
            end_string = end_string:gsub("<extruder_swap_retract_speed>",round(extruder_swap_retract_speed_mm_per_sec*60,0))
            end_string = end_string:gsub("<z_lift>",f(z_lift_mm))
            end_string = end_string:gsub("<extruder_swap_z_lift>",f(extruder_swap_zlift_mm))
            end_string = end_string:gsub("<current_layer_zheight>",f(current_layer_zheight))
            end_string = end_string:gsub("<current_extruder>",current_extruder)
            end_string = end_string:gsub("<z_movement_speed>",round(z_movement_speed_mm_per_sec*60,0))
            end_string = end_string:gsub("<e_movement_speed>",round(e_movement_speed_mm_per_sec*60,0))
            end_string = end_string:gsub("<travel_speed>",round(travel_speed_mm_per_sec*60,0))
            end_string = end_string:gsub("<print_x_min>",f(min_corner_x))
            end_string = end_string:gsub("<print_x_max>",f(min_corner_x + extent_x))
            end_string = end_string:gsub("<print_y_min>",f(min_corner_y))
            end_string = end_string:gsub("<print_y_max>",f(min_corner_y + extent_y))
            end_string = end_string:gsub("<print_z_max>",f(extent_z))
            end_string = end_string:gsub("<fan_percent>",round(current_fan_speed/100,2))

            output(end_string)
        end
    end
end

function extruder_start()
    -- Function Diagnostic output:
    if function_debug then
        comment("extruder_start()")
    end
    -- Function not used by profile.
end

function extruder_stop()
    -- Function Diagnostic output:
    if function_debug then
        comment("extruder_stop()")
    end
    -- Function not used by profile.
end

function select_extruder(extruder)
    -- Function Diagnostic output:
    if function_debug then
        comment("select_extruder(" .. extruder .. ")")
    end

    -- Gcode output:
    if suppress_rrf_tool_macros_at_start and not suppress_all_tool_selection_at_start then
        output("T" .. extruder .. " P0")
    elseif not suppress_all_tool_selection_at_start then
        output("T" .. extruder)
    end

    -- Function post-calculations:
    selecting_tools_at_start = true
    previous_extruder = current_extruder
    current_extruder = extruder
end

function swap_extruder(from,to,x,y,z)
    -- Function Diagnostic output:
    if function_debug then
        comment("swap_extruder(" .. from .. "," .. to .. "," .. x .. "," .. y .. "," .. z .. ")")
    end

    --GCode output:
    if insert_swappre_gcode then
        local swappre_string = file("swappre.g")
        swappre_string = swappre_string:gsub("\r","")
        swappre_string = swappre_string:gsub("<x>",f(x))
        swappre_string = swappre_string:gsub("<y>",f(y))
        swappre_string = swappre_string:gsub("<z>",f(z))
        swappre_string = swappre_string:gsub("<retract_length_from>",ff(filament_priming_mm[from]))
        swappre_string = swappre_string:gsub("<retract_length_to>",ff(filament_priming_mm[to]))
        swappre_string = swappre_string:gsub("<retract_speed_from>",round(priming_mm_per_sec[from]*60,0))
        swappre_string = swappre_string:gsub("<retract_speed_to>",round(priming_mm_per_sec[to]*60,0))
        swappre_string = swappre_string:gsub("<extruder_swap_retract_length>",ff(extruder_swap_retract_length_mm))
        swappre_string = swappre_string:gsub("<extruder_swap_retract_speed>",round(extruder_swap_retract_speed_mm_per_sec*60,0))
        swappre_string = swappre_string:gsub("<z_lift>",f(z_lift_mm))
        swappre_string = swappre_string:gsub("<extruder_swap_z_lift>",f(extruder_swap_zlift_mm))
        swappre_string = swappre_string:gsub("<current_layer_zheight>",f(current_layer_zheight))
        swappre_string = swappre_string:gsub("<from_extruder>",from)
        swappre_string = swappre_string:gsub("<to_extruder>",to)
        swappre_string = swappre_string:gsub("<z_movement_speed>",round(z_movement_speed_mm_per_sec*60,0))
        swappre_string = swappre_string:gsub("<e_movement_speed>",round(e_movement_speed_mm_per_sec*60,0))
        swappre_string = swappre_string:gsub("<travel_speed>",round(travel_speed_mm_per_sec*60,0))
        swappre_string = swappre_string:gsub("<print_x_min>",f(min_corner_x))
        swappre_string = swappre_string:gsub("<print_x_max>",f(min_corner_x + extent_x))
        swappre_string = swappre_string:gsub("<print_y_min>",f(min_corner_y))
        swappre_string = swappre_string:gsub("<print_y_max>",f(min_corner_y + extent_y))
        swappre_string = swappre_string:gsub("<print_z_max>",f(extent_z))
        swappre_string = swappre_string:gsub("<fan_percent>",round(current_fan_speed/100,2))
    
        output(swappre_string)
    end

    output("T" .. to)

    if insert_swap_gcode then
        local swap_string = file("swap.g")
        swap_string = swap_string:gsub("\r","")
        swap_string = swap_string:gsub("<x>",f(x))
        swap_string = swap_string:gsub("<y>",f(y))
        swap_string = swap_string:gsub("<z>",f(z))
        swap_string = swap_string:gsub("<retract_length_from>",ff(filament_priming_mm[from]))
        swap_string = swap_string:gsub("<retract_length_to>",ff(filament_priming_mm[to]))
        swap_string = swap_string:gsub("<retract_speed_from>",round(priming_mm_per_sec[from]*60,0))
        swap_string = swap_string:gsub("<retract_speed_to>",round(priming_mm_per_sec[to]*60,0))
        swap_string = swap_string:gsub("<extruder_swap_retract_length>",ff(extruder_swap_retract_length_mm))
        swap_string = swap_string:gsub("<extruder_swap_retract_speed>",round(extruder_swap_retract_speed_mm_per_sec*60,0))
        swap_string = swap_string:gsub("<z_lift>",f(z_lift_mm))
        swap_string = swap_string:gsub("<extruder_swap_z_lift>",f(extruder_swap_zlift_mm))
        swap_string = swap_string:gsub("<current_layer_zheight>",f(current_layer_zheight))
        swap_string = swap_string:gsub("<from_extruder>",from)
        swap_string = swap_string:gsub("<to_extruder>",to)
        swap_string = swap_string:gsub("<z_movement_speed>",round(z_movement_speed_mm_per_sec*60,0))
        swap_string = swap_string:gsub("<e_movement_speed>",round(e_movement_speed_mm_per_sec*60,0))
        swap_string = swap_string:gsub("<travel_speed>",round(travel_speed_mm_per_sec*60,0))
        swap_string = swap_string:gsub("<print_x_min>",f(min_corner_x))
        swap_string = swap_string:gsub("<print_x_max>",f(min_corner_x + extent_x))
        swap_string = swap_string:gsub("<print_y_min>",f(min_corner_y))
        swap_string = swap_string:gsub("<print_y_max>",f(min_corner_y + extent_y))
        swap_string = swap_string:gsub("<print_z_max>",f(extent_z))
        swap_string = swap_string:gsub("<fan_percent>",round(current_fan_speed/100,2))
    
        output(swap_string)
    end

    -- Function post-calculations:
    previous_extruder = from
    current_extruder = to
end

function retract(extruder,e)
    -- Function Diagnostic output:
    if function_debug then
        comment("retract(" .. extruder .. "," .. e .. ")")
    end

    -- GCode output:
    if not selecting_tools_at_start then
        if firmware_retraction then
            output("G10")
        elseif volumetric_extrusion and relative_extrusion then
            set_feedrate(priming_mm_per_sec[current_extruder] * 60)
            output("G1 E-" .. ff(math.pi * (filament_diameter_mm[current_extruder] / 2)^2 * filament_priming_mm[current_extruder]) .. " F" .. round(current_feedrate,0))
        elseif relative_extrusion then
            set_feedrate(priming_mm_per_sec[current_extruder] * 60)
            output("G1 E-" .. ff(filament_priming_mm[current_extruder]) .. " F" .. round(current_feedrate,0))
        end

        if enable_z_lift and z_lift_on_retract then
            if not firmware_retraction then
                set_feedrate(z_movement_speed_mm_per_sec * 60)
                output("G1 Z" .. f(current_layer_zheight + z_lift_mm) .. " F" .. round(current_feedrate,0))
                previous_z = current_layer_zheight + z_lift_mm
            end
        end
    elseif function_debug then
        comment("retract() skipped due to start tool selection")
    end

    -- Function post-calculations:
    return e
end

function prime(extruder,e)
    -- Function Diagnostic output:
    if function_debug then
        comment("prime(" .. extruder .. "," .. e .. ")")
    end

    -- GCode output:
    if not selecting_tools_at_start then
        if enable_z_lift and z_lift_on_retract then
            if not firmware_retraction and previous_z ~= current_layer_zheight then
                set_feedrate(z_movement_speed_mm_per_sec * 60)
                output("G1 Z" .. f(current_layer_zheight) .. " F" .. round(current_feedrate,0))
                previous_z = current_layer_zheight
            end
        end

        if firmware_retraction then
            output("G11")
        elseif volumetric_extrusion and relative_extrusion then
            set_feedrate(priming_mm_per_sec[current_extruder] * 60)
            output("G1 E" .. ff(math.pi * (filament_diameter_mm[current_extruder] / 2)^2 * filament_priming_mm[current_extruder]) .. " F" .. round(current_feedrate,0))        
        elseif relative_extrusion then
            set_feedrate(priming_mm_per_sec[current_extruder] * 60)
            output("G1 E" .. ff(filament_priming_mm[current_extruder]) .. " F" .. round(current_feedrate,0))
        end
    elseif function_debug then
        comment("prime() skipped due to start tool selection")
    end

    -- Function post-calculations:
    if selecting_tools_at_start then selecting_tools_at_start = false end
    return e
end

function move_e(e)
    -- Function Diagnostic output:
    if function_debug then
        comment("move_e(" .. e .. ")")
    end

    -- Function pre-calculations:
    filament_to_extrude_this_move = e-already_extruded[current_extruder]

    if move_debug or volumetric_extrusion and relative_extrusion then
        move_volume = math.pi * (filament_diameter_mm[current_extruder] / 2)^2 * filament_to_extrude_this_move
    end

    -- Movement Diagnostic output:
    if move_debug then
        comment("E: " .. fff(filament_to_extrude_this_move) .. " V: " .. fff(move_volume))
    end

    -- GCode output:
    local e_string = ""
    local f_string = ""

    if volumetric_extrusion and relative_extrusion then
        e_string = " E" .. ff(move_volume)
    elseif relative_extrusion then
        e_string = " E" .. ff(filament_to_extrude_this_move)
    end

    if current_feedrate ~= e_movement_speed_mm_per_sec * 60 then
        set_feedrate(e_movement_speed_mm_per_sec * 60)
        f_string = " F" .. round(current_feedrate,0)
    end

    output("G1" .. e_string .. f_string)

    -- Function post-calculations:
    already_extruded[current_extruder] = e
end

function move_xyz(x,y,z)
    -- Function Diagnostic output:
    if function_debug then
        comment("move_xyz(" .. x .. "," .. y .. "," .. z .. ")")
    end

    -- Movement Diagnostic output:
    if move_debug then
        move_length = math.sqrt((x - previous_x)^2 + (y - previous_y)^2 + (z - previous_z)^2)
        comment("X: " .. fff(x) .. " Y: " .. fff(y) .. " Z: " .. fff(z) .. " L: " .. fff(move_length))
    end

    -- GCode Output
    local z_string = ""
    local f_string = ""

    if z ~= previous_z and not z_lift_on_retract then
        z_string = " Z" .. f(z)
        previous_z = z
    end

    if current_feedrate ~= previous_feedrate then
        set_feedrate(current_feedrate)
        f_string = " F" .. round(current_feedrate,0)
    end

    output("G1 X" .. f(x) .. " Y" .. f(y) .. z_string .. f_string)

    -- Function post-calculations:
    previous_x = x
    previous_y = y
end

function move_xyze(x,y,z,e)
    -- Function Diagnostic output:
    if function_debug then
        comment("move_xyze(" .. x .. "," .. y .. "," .. z .. "," .. e .. ")")
    end

    -- Function pre-calculations:
    filament_to_extrude_this_move = e-already_extruded[current_extruder]

    if s3d_debug or move_debug or volumetric_extrusion and relative_extrusion then
        move_volume = math.pi * (filament_diameter_mm[current_extruder] / 2)^2 * filament_to_extrude_this_move
    end

    if s3d_debug or move_debug then
        move_length = math.sqrt((x - previous_x)^2 + (y - previous_y)^2 + (z - previous_z)^2)
        previous_move_calculated_extrusion_width = current_move_calculated_extrusion_width
        current_move_calculated_extrusion_width = move_volume / (current_layer_thickness * move_length)
    end

    -- Path labeling:
    if path_is_perimeter and previous_path_was ~= "perimeter" then
        if craftware_debug then
            output(";segType:Perimeter")
        elseif s3d_debug then
            comment("feature outer perimeter")
        else
            comment("perimeter")
        end
        previous_path_was = "perimeter"
    elseif path_is_shell and not path_is_cover and previous_path_was ~= "shell" then
        if craftware_debug then
            output(";segType:HShell")
        elseif s3d_debug then
            comment("feature inner perimeter")
        else
            comment("shell")
        end
        previous_path_was = "shell"
    elseif path_is_infill and not path_is_cover and previous_path_was ~= "infill" then
        if craftware_debug then
            output(";segType:Infill")
        elseif s3d_debug then
            comment("feature infill")
        else
            comment("infill")
        end
        previous_path_was = "infill"
    elseif path_is_brim and previous_path_was ~= "brim" then
        if craftware_debug then
            output(";segType:Skirt")
        elseif s3d_debug then
            comment("feature skirt")
        else
            comment("brim")
        end
        previous_path_was = "brim"
    elseif path_is_raft and previous_path_was ~= "raft" then
        if craftware_debug then
            output(";segType:Raft")
        elseif s3d_debug then
            comment("feature raft")
        else
            comment("raft")
        end
        previous_path_was = "raft"
    elseif path_is_shield and previous_path_was ~= "shield" then
        if craftware_debug then
            output(";segType:Pillar")
        elseif s3d_debug then
            comment("feature ooze shield")
        else
            comment("shield")
        end
        previous_path_was = "shield"
    elseif path_is_tower and previous_path_was ~= "tower" then
        if craftware_debug then
            output(";segType:Pillar")
        elseif s3d_debug then
            comment("feature prime pillar")
        else
            comment("tower")
        end
        previous_path_was = "tower"
    elseif path_is_support and previous_path_was ~= "support" then
        if craftware_debug then
            output(";segType:Support")
        elseif s3d_debug then
            comment("feature support")
        else
            comment("support")
        end
        previous_path_was = "support"
    elseif path_is_bridge and previous_path_was ~= "bridge" then
        if craftware_debug then
            output(";segType:Infill")
        elseif s3d_debug then
            comment("feature bridge")
        else
            comment("bridge")
        end
        previous_path_was = "bridge"
    elseif path_is_cover and path_is_shell and previous_path_was ~= "cover shell" then
        if craftware_debug then
            output(";segType:Infill")
        elseif s3d_debug then
            comment("feature solid layer concentric")
        else
            comment("curved cover")
        end
        previous_path_was = "cover shell"
    elseif path_is_cover and path_is_infill and previous_path_was ~= "cover infill" then
        if craftware_debug then
            output(";segType:Infill")
        elseif s3d_debug then
            comment("feature solid layer")
        else
            comment("cover")
        end
        previous_path_was = "cover infill"
    end

    -- Path Feedrate Override:
    local scale_factor = 1

    if layer_id == 0 and first_layer_feedrate_override_scale_percent ~= 0 then
        scale_factor = first_layer_feedrate_override_scale_percent / 100
        if path_is_perimeter and current_feedrate ~= perimeter_print_speed_mm_per_sec * 60 * scale_factor then
            set_feedrate(perimeter_print_speed_mm_per_sec * 60 * scale_factor)
        elseif path_is_support and current_feedrate ~= support_print_speed_mm_per_sec * 60 * scale_factor then
            set_feedrate(support_print_speed_mm_per_sec * 60 * scale_factor)
        end
    end

    if path_is_shell and not path_is_cover and shell_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= shell_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(shell_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_infill and not path_is_cover and infill_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= infill_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(infill_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_brim and brim_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= brim_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(brim_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_raft and raft_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= raft_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(raft_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_shield and shield_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= shield_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(shield_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_tower and tower_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= tower_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(tower_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_bridge and bridge_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= bridge_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(bridge_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_cover and path_is_shell and cover_shell_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= cover_shell_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(cover_shell_feedrate_override_mm_per_sec * 60 * scale_factor)
    elseif path_is_cover and path_is_infill and cover_infill_feedrate_override_mm_per_sec ~= 0 and current_feedrate ~= cover_infill_feedrate_override_mm_per_sec * 60 * scale_factor then
        set_feedrate(cover_infill_feedrate_override_mm_per_sec * 60 * scale_factor)
    end

    -- S3D Output Emulation for toolpath visualization:
    if s3d_debug then
        if z ~= previous_z then
            local nonplanar_move_thickness = move_volume / (move_length * _G["nozzle_diameter_mm_" .. current_extruder])
            comment("tool H" .. f(nonplanar_move_thickness) .. " W" .. f(_G["nozzle_diameter_mm_" .. current_extruder]) .. "\nCaution: S3D Output Emulation is currently incompatible with non-x/y-planar print moves. These values are best guesses only.") -- Sorry for the tool comment every line.
        elseif f(current_move_calculated_extrusion_width) ~= f(previous_move_calculated_extrusion_width) then
            comment("tool H" .. f(current_layer_thickness) .. " W" .. f(current_move_calculated_extrusion_width))
        end
    end

    -- Movement Diagnostic output:
    if move_debug then
        if z ~= previous_z then
            local nonplanar_move_thickness = move_volume / (move_length * _G["nozzle_diameter_mm_" .. current_extruder])
            comment("X: " .. fff(x) .. " Y: " .. fff(y) .. " Z: " .. fff(z) .. " E: " .. fff(filament_to_extrude_this_move) .. " W: " .. fff(_G["nozzle_diameter_mm_" .. current_extruder]) .. " H: " .. fff(nonplanar_move_thickness) .. " L: " .. fff(move_length) .. " V: " .. fff(move_volume) .. " Caution: Non-x/y-planar moves can cause Movement Diagnostic info to be incorrect. These values should be verified manually.") -- Again, sorry for the comment on every line.
        else
            comment("X: " .. fff(x) .. " Y: " .. fff(y) .. " Z: " .. fff(z) .. " E: " .. fff(filament_to_extrude_this_move) .. " W: " .. fff(current_move_calculated_extrusion_width) .. " H: " .. fff(current_layer_thickness) .. " L: " .. fff(move_length) .. " V: " .. fff(move_volume))
        end
    end

    -- GCode output:
    local z_string = ""
    local e_string = ""
    local f_string = ""

    if z ~= previous_z then
        z_string = " Z" .. f(z)
    end

    if volumetric_extrusion and relative_extrusion then
        e_string = " E" .. ff(move_volume)
    elseif relative_extrusion then
        e_string = " E" .. ff(filament_to_extrude_this_move)
    end

    if current_feedrate ~= previous_feedrate then
        set_feedrate(current_feedrate)
        f_string = " F" .. round(current_feedrate,0)
    end

    output("G1 X" .. f(x) .. " Y" .. f(y) .. z_string .. e_string .. f_string)

    -- Function post-calculations:
    already_extruded[current_extruder] = e
    previous_x = x
    previous_y = y
    previous_z = z
end

function progress(percent)
    -- Function Diagnostic output:
    if function_debug then
        comment("progress(" .. percent .. ")")
    end
    -- Function not yet implemented in profile.
end

function set_feedrate(feedrate)
    -- Function Diagnostic output:
    if function_debug then
        comment("set_feedrate(" .. feedrate .. ")")
    end

    --Function calculations
    previous_feedrate = current_feedrate
    current_feedrate = feedrate
end

function set_fan_speed(speed)
    -- Function Diagnostic output:
    if function_debug then
        comment("set_fan_speed(" .. speed .. ")")
    end

    -- Function pre-calculations:
    previous_fan_speed = current_fan_speed
    current_fan_speed = speed

    -- Gcode output:
    if current_fan_speed ~= previous_fan_speed then
        if suppress_fan_at_start and previous_fan_speed == -1 then
            previous_fan_speed = 0
        else
            output("M106 S" .. round(speed/100,2))
        end
    end
end

function set_extruder_temperature(extruder,temperature)
    -- Function Diagnostic output:
    if function_debug then
        comment("set_extruder_temperature(" .. extruder .. "," .. temperature .. ")")
    end    

    -- GCode output:
    if enable_active_temperature_control then
        output("G10 P" .. extruder .. " R" .. round(temperature,1))
    end    
end    

function set_and_wait_extruder_temperature(extruder,temperature)
    -- Function Diagnostic output:
    if function_debug then
        comment("set_and_wait_extruder_temperature(" .. extruder .. "," .. temperature .. ")")
    end

    -- GCode output:
    if not suppress_temp_control then
        if enable_active_temperature_control then
            output("G10 P" .. extruder .. " R" .. round(_G["idle_extruder_temp_degree_c_" .. current_extruder],1))
        end
        output("M116 P" .. extruder)
    end
end

function wait(sec,x,y,z)
    -- Function Diagnostic output:
    if function_debug then
        comment("wait(" .. sec .. "," .. x .. "," .. y .. "," .. z .. ")")
    end

    -- GCode output:
    local wait_string = file("wait.g")
    wait_string = wait_string:gsub("\r","")
    wait_string = wait_string:gsub("<sec>",round(sec,0))
    wait_string = wait_string:gsub("<x>",f(x))
    wait_string = wait_string:gsub("<y>",f(y))
    wait_string = wait_string:gsub("<z>",f(z))
    wait_string = wait_string:gsub("<retract_length>",ff(filament_priming_mm[current_extruder]))
    wait_string = wait_string:gsub("<retract_speed>",round(priming_mm_per_sec[current_extruder]*60,0))
    wait_string = wait_string:gsub("<extruder_swap_retract_length>",ff(extruder_swap_retract_length_mm))
    wait_string = wait_string:gsub("<extruder_swap_retract_speed>",round(extruder_swap_retract_speed_mm_per_sec*60,0))
    wait_string = wait_string:gsub("<z_lift>",f(z_lift_mm))
    wait_string = wait_string:gsub("<extruder_swap_z_lift>",f(extruder_swap_zlift_mm))
    wait_string = wait_string:gsub("<current_layer_zheight>",f(current_layer_zheight))
    wait_string = wait_string:gsub("<current_extruder>",current_extruder)
    wait_string = wait_string:gsub("<z_movement_speed>",round(z_movement_speed_mm_per_sec*60,0))
    wait_string = wait_string:gsub("<e_movement_speed>",round(e_movement_speed_mm_per_sec*60,0))
    wait_string = wait_string:gsub("<travel_speed>",round(travel_speed_mm_per_sec*60,0))
    wait_string = wait_string:gsub("<print_x_min>",f(min_corner_x))
    wait_string = wait_string:gsub("<print_x_max>",f(min_corner_x + extent_x))
    wait_string = wait_string:gsub("<print_y_min>",f(min_corner_y))
    wait_string = wait_string:gsub("<print_y_max>",f(min_corner_y + extent_y))
    wait_string = wait_string:gsub("<print_z_max>",f(extent_z))
    wait_string = wait_string:gsub("<fan_percent>",round(current_fan_speed/100,2))

    comment("wait for " .. round(sec,0) .. " seconds to achieve minimum layer time of " .. round(min_layer_time_sec,0) .. " seconds")
    output(wait_string)
end

function set_mixing_ratios(ratios)
    -- Function Diagnostic output:
    if function_debug then
        comment("set_mixing_ratios(ratios) Note: contents of table ratios not listed in this debug output.")
    end
    -- Function not yet implemented in profile.
end
-- End of file.